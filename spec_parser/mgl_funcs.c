void mglAccum(GLMContext ctx, GLenum op, GLfloat value)
{
    assert(0);    // incomplete function
}

void mglAlphaFunc(GLMContext ctx, GLenum func, GLclampf ref)
{
    assert(0);    // incomplete function
}

GLboolean mglAreTexturesResident(GLMContext ctx, GLsizei n, GLuint* textures, GLboolean* residences)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglArrayElement(GLMContext ctx, GLint i)
{
    assert(0);    // incomplete function
}

void mglBegin(GLMContext ctx, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglBindTexture(GLMContext ctx, GLenum target, GLuint texture)
{
    assert(0);    // incomplete function
}

void mglBitmap(GLMContext ctx, GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, GLubyte* bitmap)
{
    assert(0);    // incomplete function
}

void mglBlendFunc(GLMContext ctx, GLenum sfactor, GLenum dfactor)
{
    assert(0);    // incomplete function
}

void mglCallList(GLMContext ctx, GLuint list)
{
    assert(0);    // incomplete function
}

void mglCallLists(GLMContext ctx, GLsizei n, GLenum type,const GLvoid*lists)
{
    assert(0);    // incomplete function
}

void mglClear(GLMContext ctx, GLbitfield mask)
{
    assert(0);    // incomplete function
}

void mglClearAccum(GLMContext ctx, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
    assert(0);    // incomplete function
}

void mglClearColor(GLMContext ctx, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
    assert(0);    // incomplete function
}

void mglClearDepth(GLMContext ctx, GLclampd depth)
{
    assert(0);    // incomplete function
}

void mglClearIndex(GLMContext ctx, GLfloat c)
{
    assert(0);    // incomplete function
}

void mglClearStencil(GLMContext ctx, GLint s)
{
    assert(0);    // incomplete function
}

void mglClipPlane(GLMContext ctx, GLenum plane, GLdouble* equation)
{
    assert(0);    // incomplete function
}

void mglColor3b(GLMContext ctx, GLbyte red, GLbyte green, GLbyte blue)
{
    assert(0);    // incomplete function
}

void mglColor3bv(GLMContext ctx, GLbyte* v)
{
    assert(0);    // incomplete function
}

void mglColor3d(GLMContext ctx, GLdouble red, GLdouble green, GLdouble blue)
{
    assert(0);    // incomplete function
}

void mglColor3dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglColor3f(GLMContext ctx, GLfloat red, GLfloat green, GLfloat blue)
{
    assert(0);    // incomplete function
}

void mglColor3fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglColor3i(GLMContext ctx, GLint red, GLint green, GLint blue)
{
    assert(0);    // incomplete function
}

void mglColor3iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglColor3s(GLMContext ctx, GLshort red, GLshort green, GLshort blue)
{
    assert(0);    // incomplete function
}

void mglColor3sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglColor3ub(GLMContext ctx, GLubyte red, GLubyte green, GLubyte blue)
{
    assert(0);    // incomplete function
}

void mglColor3ubv(GLMContext ctx, GLubyte* v)
{
    assert(0);    // incomplete function
}

void mglColor3ui(GLMContext ctx, GLuint red, GLuint green, GLuint blue)
{
    assert(0);    // incomplete function
}

void mglColor3uiv(GLMContext ctx, GLuint* v)
{
    assert(0);    // incomplete function
}

void mglColor3us(GLMContext ctx, GLushort red, GLushort green, GLushort blue)
{
    assert(0);    // incomplete function
}

void mglColor3usv(GLMContext ctx, GLushort* v)
{
    assert(0);    // incomplete function
}

void mglColor4b(GLMContext ctx, GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
    assert(0);    // incomplete function
}

void mglColor4bv(GLMContext ctx, GLbyte* v)
{
    assert(0);    // incomplete function
}

void mglColor4d(GLMContext ctx, GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{
    assert(0);    // incomplete function
}

void mglColor4dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglColor4f(GLMContext ctx, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
    assert(0);    // incomplete function
}

void mglColor4fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglColor4i(GLMContext ctx, GLint red, GLint green, GLint blue, GLint alpha)
{
    assert(0);    // incomplete function
}

void mglColor4iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglColor4s(GLMContext ctx, GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
    assert(0);    // incomplete function
}

void mglColor4sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglColor4ub(GLMContext ctx, GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
    assert(0);    // incomplete function
}

void mglColor4ubv(GLMContext ctx, GLubyte* v)
{
    assert(0);    // incomplete function
}

void mglColor4ui(GLMContext ctx, GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
    assert(0);    // incomplete function
}

void mglColor4uiv(GLMContext ctx, GLuint* v)
{
    assert(0);    // incomplete function
}

void mglColor4us(GLMContext ctx, GLushort red, GLushort green, GLushort blue, GLushort alpha)
{
    assert(0);    // incomplete function
}

void mglColor4usv(GLMContext ctx, GLushort* v)
{
    assert(0);    // incomplete function
}

void mglColorMask(GLMContext ctx, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
    assert(0);    // incomplete function
}

void mglColorMaterial(GLMContext ctx, GLenum face, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglColorPointer(GLMContext ctx, GLint size, GLenum type, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglCopyPixels(GLMContext ctx, GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
    assert(0);    // incomplete function
}

void mglCopyTexImage1D(GLMContext ctx, GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
{
    assert(0);    // incomplete function
}

void mglCopyTexImage2D(GLMContext ctx, GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
    assert(0);    // incomplete function
}

void mglCopyTexSubImage1D(GLMContext ctx, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
    assert(0);    // incomplete function
}

void mglCopyTexSubImage2D(GLMContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    assert(0);    // incomplete function
}

void mglCullFace(GLMContext ctx, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglDeleteLists(GLMContext ctx, GLuint list, GLsizei range)
{
    assert(0);    // incomplete function
}

void mglDeleteTextures(GLMContext ctx, GLsizei n, GLuint* textures)
{
    assert(0);    // incomplete function
}

void mglDepthFunc(GLMContext ctx, GLenum func)
{
    assert(0);    // incomplete function
}

void mglDepthMask(GLMContext ctx, GLboolean flag)
{
    assert(0);    // incomplete function
}

void mglDepthRange(GLMContext ctx, GLclampd zNear, GLclampd zFar)
{
    assert(0);    // incomplete function
}

void mglDisable(GLMContext ctx, GLenum cap)
{
    assert(0);    // incomplete function
}

void mglDisableClientState(GLMContext ctx, GLenum array)
{
    assert(0);    // incomplete function
}

void mglDrawArrays(GLMContext ctx, GLenum mode, GLint first, GLsizei count)
{
    assert(0);    // incomplete function
}

void mglDrawBuffer(GLMContext ctx, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglDrawElements(GLMContext ctx, GLenum mode, GLsizei count, GLenum type,const GLvoid*indices)
{
    assert(0);    // incomplete function
}

void mglDrawPixels(GLMContext ctx, GLsizei width, GLsizei height, GLenum format, GLenum type,const GLvoid*pixels)
{
    assert(0);    // incomplete function
}

void mglEdgeFlag(GLMContext ctx, GLboolean flag)
{
    assert(0);    // incomplete function
}

void mglEdgeFlagPointer(GLMContext ctx, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglEdgeFlagv(GLMContext ctx, GLboolean* flag)
{
    assert(0);    // incomplete function
}

void mglEnable(GLMContext ctx, GLenum cap)
{
    assert(0);    // incomplete function
}

void mglEnableClientState(GLMContext ctx, GLenum array)
{
    assert(0);    // incomplete function
}

void mglEnd(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglEndList(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglEvalCoord1d(GLMContext ctx, GLdouble u)
{
    assert(0);    // incomplete function
}

void mglEvalCoord1dv(GLMContext ctx, GLdouble* u)
{
    assert(0);    // incomplete function
}

void mglEvalCoord1f(GLMContext ctx, GLfloat u)
{
    assert(0);    // incomplete function
}

void mglEvalCoord1fv(GLMContext ctx, const GLfloat* u)
{
    assert(0);    // incomplete function
}

void mglEvalCoord2d(GLMContext ctx, GLdouble u, GLdouble v)
{
    assert(0);    // incomplete function
}

void mglEvalCoord2dv(GLMContext ctx, GLdouble* u)
{
    assert(0);    // incomplete function
}

void mglEvalCoord2f(GLMContext ctx, GLfloat u, GLfloat v)
{
    assert(0);    // incomplete function
}

void mglEvalCoord2fv(GLMContext ctx, const GLfloat* u)
{
    assert(0);    // incomplete function
}

void mglEvalMesh1(GLMContext ctx, GLenum mode, GLint i1, GLint i2)
{
    assert(0);    // incomplete function
}

void mglEvalMesh2(GLMContext ctx, GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
    assert(0);    // incomplete function
}

void mglEvalPoint1(GLMContext ctx, GLint i)
{
    assert(0);    // incomplete function
}

void mglEvalPoint2(GLMContext ctx, GLint i, GLint j)
{
    assert(0);    // incomplete function
}

void mglFeedbackBuffer(GLMContext ctx, GLsizei size, GLenum type, const GLfloat* buffer)
{
    assert(0);    // incomplete function
}

void mglFinish(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglFlush(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglFogf(GLMContext ctx, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglFogfv(GLMContext ctx, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglFogi(GLMContext ctx, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglFogiv(GLMContext ctx, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglFrontFace(GLMContext ctx, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglFrustum(GLMContext ctx, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
    assert(0);    // incomplete function
}

GLuint mglGenLists(GLMContext ctx, GLsizei range)
{
    GLuint ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglGenTextures(GLMContext ctx, GLsizei n, GLuint* textures)
{
    assert(0);    // incomplete function
}

void mglGetBooleanv(GLMContext ctx, GLenum pname, GLboolean* params)
{
    assert(0);    // incomplete function
}

void mglGetClipPlane(GLMContext ctx, GLenum plane, GLdouble* equation)
{
    assert(0);    // incomplete function
}

void mglGetDoublev(GLMContext ctx, GLenum pname, GLdouble* params)
{
    assert(0);    // incomplete function
}

GLenum mglGetError(GLMContext ctx)
{
    GLenum ret = (GLenum)0;

    assert(0);    // incomplete function
    return ret;
}

void mglGetFloatv(GLMContext ctx, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetIntegerv(GLMContext ctx, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetLightfv(GLMContext ctx, GLenum light, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetLightiv(GLMContext ctx, GLenum light, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetMapdv(GLMContext ctx, GLenum target, GLenum query, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglGetMapfv(GLMContext ctx, GLenum target, GLenum query, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglGetMapiv(GLMContext ctx, GLenum target, GLenum query, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglGetMaterialfv(GLMContext ctx, GLenum face, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetMaterialiv(GLMContext ctx, GLenum face, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetPixelMapfv(GLMContext ctx, GLenum map, const GLfloat* values)
{
    assert(0);    // incomplete function
}

void mglGetPixelMapuiv(GLMContext ctx, GLenum map, GLuint* values)
{
    assert(0);    // incomplete function
}

void mglGetPixelMapusv(GLMContext ctx, GLenum map, GLushort* values)
{
    assert(0);    // incomplete function
}

void mglGetPointerv(GLMContext ctx, GLenum pname, const GLvoid* const * params)
{
    assert(0);    // incomplete function
}

void mglGetPolygonStipple(GLMContext ctx, GLubyte* mask)
{
    assert(0);    // incomplete function
}

GLubyte* mglGetString(GLMContext ctx, GLenum name)
{
    GLubyte *ret = NULL;

    assert(0);    // incomplete function
    return ret;
}

void mglGetTexEnvfv(GLMContext ctx, GLenum target, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetTexEnviv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetTexGendv(GLMContext ctx, GLenum coord, GLenum pname, GLdouble* params)
{
    assert(0);    // incomplete function
}

void mglGetTexGenfv(GLMContext ctx, GLenum coord, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetTexGeniv(GLMContext ctx, GLenum coord, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetTexImage(GLMContext ctx, GLenum target, GLint level, GLenum format, GLenum type,const GLvoid*pixels)
{
    assert(0);    // incomplete function
}

void mglGetTexLevelParameterfv(GLMContext ctx, GLenum target, GLint level, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetTexLevelParameteriv(GLMContext ctx, GLenum target, GLint level, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetTexParameterfv(GLMContext ctx, GLenum target, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetTexParameteriv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglHint(GLMContext ctx, GLenum target, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglIndexMask(GLMContext ctx, GLuint mask)
{
    assert(0);    // incomplete function
}

void mglIndexPointer(GLMContext ctx, GLenum type, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglIndexd(GLMContext ctx, GLdouble c)
{
    assert(0);    // incomplete function
}

void mglIndexdv(GLMContext ctx, GLdouble* c)
{
    assert(0);    // incomplete function
}

void mglIndexf(GLMContext ctx, GLfloat c)
{
    assert(0);    // incomplete function
}

void mglIndexfv(GLMContext ctx, const GLfloat* c)
{
    assert(0);    // incomplete function
}

void mglIndexi(GLMContext ctx, GLint c)
{
    assert(0);    // incomplete function
}

void mglIndexiv(GLMContext ctx, const GLint*  c)
{
    assert(0);    // incomplete function
}

void mglIndexs(GLMContext ctx, GLshort c)
{
    assert(0);    // incomplete function
}

void mglIndexsv(GLMContext ctx, GLshort* c)
{
    assert(0);    // incomplete function
}

void mglIndexub(GLMContext ctx, GLubyte c)
{
    assert(0);    // incomplete function
}

void mglIndexubv(GLMContext ctx, GLubyte* c)
{
    assert(0);    // incomplete function
}

void mglInitNames(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglInterleavedArrays(GLMContext ctx, GLenum format, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

GLboolean mglIsEnabled(GLMContext ctx, GLenum cap)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

GLboolean mglIsList(GLMContext ctx, GLuint list)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

GLboolean mglIsTexture(GLMContext ctx, GLuint texture)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglLightModelf(GLMContext ctx, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglLightModelfv(GLMContext ctx, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglLightModeli(GLMContext ctx, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglLightModeliv(GLMContext ctx, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglLightf(GLMContext ctx, GLenum light, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglLightfv(GLMContext ctx, GLenum light, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglLighti(GLMContext ctx, GLenum light, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglLightiv(GLMContext ctx, GLenum light, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglLineStipple(GLMContext ctx, GLint factor, GLushort pattern)
{
    assert(0);    // incomplete function
}

void mglLineWidth(GLMContext ctx, GLfloat width)
{
    assert(0);    // incomplete function
}

void mglListBase(GLMContext ctx, GLuint base)
{
    assert(0);    // incomplete function
}

void mglLoadIdentity(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglLoadMatrixd(GLMContext ctx, GLdouble* m)
{
    assert(0);    // incomplete function
}

void mglLoadMatrixf(GLMContext ctx, const GLfloat* m)
{
    assert(0);    // incomplete function
}

void mglLoadName(GLMContext ctx, GLuint name)
{
    assert(0);    // incomplete function
}

void mglLogicOp(GLMContext ctx, GLenum opcode)
{
    assert(0);    // incomplete function
}

void mglMap1d(GLMContext ctx, GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, GLdouble* points)
{
    assert(0);    // incomplete function
}

void mglMap1f(GLMContext ctx, GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points)
{
    assert(0);    // incomplete function
}

void mglMap2d(GLMContext ctx, GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble* points)
{
    assert(0);    // incomplete function
}

void mglMap2f(GLMContext ctx, GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points)
{
    assert(0);    // incomplete function
}

void mglMapGrid1d(GLMContext ctx, GLint un, GLdouble u1, GLdouble u2)
{
    assert(0);    // incomplete function
}

void mglMapGrid1f(GLMContext ctx, GLint un, GLfloat u1, GLfloat u2)
{
    assert(0);    // incomplete function
}

void mglMapGrid2d(GLMContext ctx, GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
    assert(0);    // incomplete function
}

void mglMapGrid2f(GLMContext ctx, GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
    assert(0);    // incomplete function
}

void mglMaterialf(GLMContext ctx, GLenum face, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglMaterialfv(GLMContext ctx, GLenum face, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglMateriali(GLMContext ctx, GLenum face, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglMaterialiv(GLMContext ctx, GLenum face, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglMatrixMode(GLMContext ctx, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglMultMatrixd(GLMContext ctx, GLdouble* m)
{
    assert(0);    // incomplete function
}

void mglMultMatrixf(GLMContext ctx, const GLfloat* m)
{
    assert(0);    // incomplete function
}

void mglNewList(GLMContext ctx, GLuint list, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglNormal3b(GLMContext ctx, GLbyte nx, GLbyte ny, GLbyte nz)
{
    assert(0);    // incomplete function
}

void mglNormal3bv(GLMContext ctx, GLbyte* v)
{
    assert(0);    // incomplete function
}

void mglNormal3d(GLMContext ctx, GLdouble nx, GLdouble ny, GLdouble nz)
{
    assert(0);    // incomplete function
}

void mglNormal3dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglNormal3f(GLMContext ctx, GLfloat nx, GLfloat ny, GLfloat nz)
{
    assert(0);    // incomplete function
}

void mglNormal3fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglNormal3i(GLMContext ctx, GLint nx, GLint ny, GLint nz)
{
    assert(0);    // incomplete function
}

void mglNormal3iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglNormal3s(GLMContext ctx, GLshort nx, GLshort ny, GLshort nz)
{
    assert(0);    // incomplete function
}

void mglNormal3sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglNormalPointer(GLMContext ctx, GLenum type, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglOrtho(GLMContext ctx, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
    assert(0);    // incomplete function
}

void mglPassThrough(GLMContext ctx, GLfloat token)
{
    assert(0);    // incomplete function
}

void mglPixelMapfv(GLMContext ctx, GLenum map, GLsizei mapsize, const GLfloat* values)
{
    assert(0);    // incomplete function
}

void mglPixelMapuiv(GLMContext ctx, GLenum map, GLsizei mapsize, GLuint* values)
{
    assert(0);    // incomplete function
}

void mglPixelMapusv(GLMContext ctx, GLenum map, GLsizei mapsize, GLushort* values)
{
    assert(0);    // incomplete function
}

void mglPixelStoref(GLMContext ctx, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglPixelStorei(GLMContext ctx, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglPixelTransferf(GLMContext ctx, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglPixelTransferi(GLMContext ctx, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglPixelZoom(GLMContext ctx, GLfloat xfactor, GLfloat yfactor)
{
    assert(0);    // incomplete function
}

void mglPointSize(GLMContext ctx, GLfloat size)
{
    assert(0);    // incomplete function
}

void mglPolygonMode(GLMContext ctx, GLenum face, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglPolygonOffset(GLMContext ctx, GLfloat factor, GLfloat units)
{
    assert(0);    // incomplete function
}

void mglPolygonStipple(GLMContext ctx, GLubyte* mask)
{
    assert(0);    // incomplete function
}

void mglPopAttrib(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglPopClientAttrib(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglPopMatrix(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglPopName(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglPrioritizeTextures(GLMContext ctx, GLsizei n, GLuint* textures, GLclampf* priorities)
{
    assert(0);    // incomplete function
}

void mglPushAttrib(GLMContext ctx, GLbitfield mask)
{
    assert(0);    // incomplete function
}

void mglPushClientAttrib(GLMContext ctx, GLbitfield mask)
{
    assert(0);    // incomplete function
}

void mglPushMatrix(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglPushName(GLMContext ctx, GLuint name)
{
    assert(0);    // incomplete function
}

void mglRasterPos2d(GLMContext ctx, GLdouble x, GLdouble y)
{
    assert(0);    // incomplete function
}

void mglRasterPos2dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglRasterPos2f(GLMContext ctx, GLfloat x, GLfloat y)
{
    assert(0);    // incomplete function
}

void mglRasterPos2fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglRasterPos2i(GLMContext ctx, GLint x, GLint y)
{
    assert(0);    // incomplete function
}

void mglRasterPos2iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglRasterPos2s(GLMContext ctx, GLshort x, GLshort y)
{
    assert(0);    // incomplete function
}

void mglRasterPos2sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglRasterPos3d(GLMContext ctx, GLdouble x, GLdouble y, GLdouble z)
{
    assert(0);    // incomplete function
}

void mglRasterPos3dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglRasterPos3f(GLMContext ctx, GLfloat x, GLfloat y, GLfloat z)
{
    assert(0);    // incomplete function
}

void mglRasterPos3fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglRasterPos3i(GLMContext ctx, GLint x, GLint y, GLint z)
{
    assert(0);    // incomplete function
}

void mglRasterPos3iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglRasterPos3s(GLMContext ctx, GLshort x, GLshort y, GLshort z)
{
    assert(0);    // incomplete function
}

void mglRasterPos3sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglRasterPos4d(GLMContext ctx, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    assert(0);    // incomplete function
}

void mglRasterPos4dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglRasterPos4f(GLMContext ctx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    assert(0);    // incomplete function
}

void mglRasterPos4fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglRasterPos4i(GLMContext ctx, GLint x, GLint y, GLint z, GLint w)
{
    assert(0);    // incomplete function
}

void mglRasterPos4iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglRasterPos4s(GLMContext ctx, GLshort x, GLshort y, GLshort z, GLshort w)
{
    assert(0);    // incomplete function
}

void mglRasterPos4sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglReadBuffer(GLMContext ctx, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglReadPixels(GLMContext ctx, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type,const GLvoid*pixels)
{
    assert(0);    // incomplete function
}

void mglRectd(GLMContext ctx, GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
    assert(0);    // incomplete function
}

void mglRectdv(GLMContext ctx, GLdouble* v1, GLdouble* v2)
{
    assert(0);    // incomplete function
}

void mglRectf(GLMContext ctx, GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
    assert(0);    // incomplete function
}

void mglRectfv(GLMContext ctx, const GLfloat* v1, const GLfloat* v2)
{
    assert(0);    // incomplete function
}

void mglRecti(GLMContext ctx, GLint x1, GLint y1, GLint x2, GLint y2)
{
    assert(0);    // incomplete function
}

void mglRectiv(GLMContext ctx, const GLint*  v1, const GLint*  v2)
{
    assert(0);    // incomplete function
}

void mglRects(GLMContext ctx, GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
    assert(0);    // incomplete function
}

void mglRectsv(GLMContext ctx, GLshort* v1, GLshort* v2)
{
    assert(0);    // incomplete function
}

GLint mglRenderMode(GLMContext ctx, GLenum mode)
{
    GLint ret = -1;

    assert(0);    // incomplete function
    return ret;
}

void mglRotated(GLMContext ctx, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
    assert(0);    // incomplete function
}

void mglRotatef(GLMContext ctx, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
    assert(0);    // incomplete function
}

void mglScaled(GLMContext ctx, GLdouble x, GLdouble y, GLdouble z)
{
    assert(0);    // incomplete function
}

void mglScalef(GLMContext ctx, GLfloat x, GLfloat y, GLfloat z)
{
    assert(0);    // incomplete function
}

void mglScissor(GLMContext ctx, GLint x, GLint y, GLsizei width, GLsizei height)
{
    assert(0);    // incomplete function
}

void mglSelectBuffer(GLMContext ctx, GLsizei size, GLuint* buffer)
{
    assert(0);    // incomplete function
}

void mglShadeModel(GLMContext ctx, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglStencilFunc(GLMContext ctx, GLenum func, GLint ref, GLuint mask)
{
    assert(0);    // incomplete function
}

void mglStencilMask(GLMContext ctx, GLuint mask)
{
    assert(0);    // incomplete function
}

void mglStencilOp(GLMContext ctx, GLenum fail, GLenum zfail, GLenum zpass)
{
    assert(0);    // incomplete function
}

void mglTexCoord1d(GLMContext ctx, GLdouble s)
{
    assert(0);    // incomplete function
}

void mglTexCoord1dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord1f(GLMContext ctx, GLfloat s)
{
    assert(0);    // incomplete function
}

void mglTexCoord1fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord1i(GLMContext ctx, GLint s)
{
    assert(0);    // incomplete function
}

void mglTexCoord1iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglTexCoord1s(GLMContext ctx, GLshort s)
{
    assert(0);    // incomplete function
}

void mglTexCoord1sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord2d(GLMContext ctx, GLdouble s, GLdouble t)
{
    assert(0);    // incomplete function
}

void mglTexCoord2dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord2f(GLMContext ctx, GLfloat s, GLfloat t)
{
    assert(0);    // incomplete function
}

void mglTexCoord2fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord2i(GLMContext ctx, GLint s, GLint t)
{
    assert(0);    // incomplete function
}

void mglTexCoord2iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglTexCoord2s(GLMContext ctx, GLshort s, GLshort t)
{
    assert(0);    // incomplete function
}

void mglTexCoord2sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord3d(GLMContext ctx, GLdouble s, GLdouble t, GLdouble r)
{
    assert(0);    // incomplete function
}

void mglTexCoord3dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord3f(GLMContext ctx, GLfloat s, GLfloat t, GLfloat r)
{
    assert(0);    // incomplete function
}

void mglTexCoord3fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord3i(GLMContext ctx, GLint s, GLint t, GLint r)
{
    assert(0);    // incomplete function
}

void mglTexCoord3iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglTexCoord3s(GLMContext ctx, GLshort s, GLshort t, GLshort r)
{
    assert(0);    // incomplete function
}

void mglTexCoord3sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord4d(GLMContext ctx, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    assert(0);    // incomplete function
}

void mglTexCoord4dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord4f(GLMContext ctx, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    assert(0);    // incomplete function
}

void mglTexCoord4fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglTexCoord4i(GLMContext ctx, GLint s, GLint t, GLint r, GLint q)
{
    assert(0);    // incomplete function
}

void mglTexCoord4iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglTexCoord4s(GLMContext ctx, GLshort s, GLshort t, GLshort r, GLshort q)
{
    assert(0);    // incomplete function
}

void mglTexCoord4sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglTexCoordPointer(GLMContext ctx, GLint size, GLenum type, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglTexEnvf(GLMContext ctx, GLenum target, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglTexEnvfv(GLMContext ctx, GLenum target, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglTexEnvi(GLMContext ctx, GLenum target, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglTexEnviv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglTexGend(GLMContext ctx, GLenum coord, GLenum pname, GLdouble param)
{
    assert(0);    // incomplete function
}

void mglTexGendv(GLMContext ctx, GLenum coord, GLenum pname, GLdouble* params)
{
    assert(0);    // incomplete function
}

void mglTexGenf(GLMContext ctx, GLenum coord, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglTexGenfv(GLMContext ctx, GLenum coord, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglTexGeni(GLMContext ctx, GLenum coord, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglTexGeniv(GLMContext ctx, GLenum coord, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglTexImage1D(GLMContext ctx, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type,const GLvoid*pixels)
{
    assert(0);    // incomplete function
}

void mglTexImage2D(GLMContext ctx, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type,const GLvoid*pixels)
{
    assert(0);    // incomplete function
}

void mglTexParameterf(GLMContext ctx, GLenum target, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglTexParameterfv(GLMContext ctx, GLenum target, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglTexParameteri(GLMContext ctx, GLenum target, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglTexParameteriv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglTexSubImage1D(GLMContext ctx, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type,const GLvoid*pixels)
{
    assert(0);    // incomplete function
}

void mglTexSubImage2D(GLMContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type,const GLvoid*pixels)
{
    assert(0);    // incomplete function
}

void mglTranslated(GLMContext ctx, GLdouble x, GLdouble y, GLdouble z)
{
    assert(0);    // incomplete function
}

void mglTranslatef(GLMContext ctx, GLfloat x, GLfloat y, GLfloat z)
{
    assert(0);    // incomplete function
}

void mglVertex2d(GLMContext ctx, GLdouble x, GLdouble y)
{
    assert(0);    // incomplete function
}

void mglVertex2dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertex2f(GLMContext ctx, GLfloat x, GLfloat y)
{
    assert(0);    // incomplete function
}

void mglVertex2fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglVertex2i(GLMContext ctx, GLint x, GLint y)
{
    assert(0);    // incomplete function
}

void mglVertex2iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglVertex2s(GLMContext ctx, GLshort x, GLshort y)
{
    assert(0);    // incomplete function
}

void mglVertex2sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglVertex3d(GLMContext ctx, GLdouble x, GLdouble y, GLdouble z)
{
    assert(0);    // incomplete function
}

void mglVertex3dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertex3f(GLMContext ctx, GLfloat x, GLfloat y, GLfloat z)
{
    assert(0);    // incomplete function
}

void mglVertex3fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglVertex3i(GLMContext ctx, GLint x, GLint y, GLint z)
{
    assert(0);    // incomplete function
}

void mglVertex3iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglVertex3s(GLMContext ctx, GLshort x, GLshort y, GLshort z)
{
    assert(0);    // incomplete function
}

void mglVertex3sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglVertex4d(GLMContext ctx, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    assert(0);    // incomplete function
}

void mglVertex4dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertex4f(GLMContext ctx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    assert(0);    // incomplete function
}

void mglVertex4fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglVertex4i(GLMContext ctx, GLint x, GLint y, GLint z, GLint w)
{
    assert(0);    // incomplete function
}

void mglVertex4iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglVertex4s(GLMContext ctx, GLshort x, GLshort y, GLshort z, GLshort w)
{
    assert(0);    // incomplete function
}

void mglVertex4sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglVertexPointer(GLMContext ctx, GLint size, GLenum type, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglViewport(GLMContext ctx, GLint x, GLint y, GLsizei width, GLsizei height)
{
    assert(0);    // incomplete function
}

void mglBlendFuncSeparate(GLMContext ctx, GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
    assert(0);    // incomplete function
}

void mglBlendColor(GLMContext ctx, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
    assert(0);    // incomplete function
}

void mglBlendEquation(GLMContext ctx, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglLockArraysEXT(GLMContext ctx, GLint first, GLsizei count)
{
    assert(0);    // incomplete function
}

void mglUnlockArraysEXT(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglClientActiveTexture(GLMContext ctx, GLenum target)
{
    assert(0);    // incomplete function
}

void mglActiveTexture(GLMContext ctx, GLenum target)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord1d(GLMContext ctx, GLenum target, GLdouble s)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord1dv(GLMContext ctx, GLenum target, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord1f(GLMContext ctx, GLenum target, GLfloat s)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord1fv(GLMContext ctx, GLenum target, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord1i(GLMContext ctx, GLenum target, GLint s)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord1iv(GLMContext ctx, GLenum target, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord1s(GLMContext ctx, GLenum target, GLshort s)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord1sv(GLMContext ctx, GLenum target, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord2d(GLMContext ctx, GLenum target, GLdouble s, GLdouble t)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord2dv(GLMContext ctx, GLenum target, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord2f(GLMContext ctx, GLenum target, GLfloat s, GLfloat t)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord2fv(GLMContext ctx, GLenum target, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord2i(GLMContext ctx, GLenum target, GLint s, GLint t)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord2iv(GLMContext ctx, GLenum target, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord2s(GLMContext ctx, GLenum target, GLshort s, GLshort t)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord2sv(GLMContext ctx, GLenum target, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord3d(GLMContext ctx, GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord3dv(GLMContext ctx, GLenum target, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord3f(GLMContext ctx, GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord3fv(GLMContext ctx, GLenum target, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord3i(GLMContext ctx, GLenum target, GLint s, GLint t, GLint r)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord3iv(GLMContext ctx, GLenum target, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord3s(GLMContext ctx, GLenum target, GLshort s, GLshort t, GLshort r)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord3sv(GLMContext ctx, GLenum target, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord4d(GLMContext ctx, GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord4dv(GLMContext ctx, GLenum target, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord4f(GLMContext ctx, GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord4fv(GLMContext ctx, GLenum target, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord4i(GLMContext ctx, GLenum target, GLint s, GLint t, GLint r, GLint q)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord4iv(GLMContext ctx, GLenum target, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord4s(GLMContext ctx, GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
    assert(0);    // incomplete function
}

void mglMultiTexCoord4sv(GLMContext ctx, GLenum target, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglLoadTransposeMatrixd(GLMContext ctx, GLdouble* m)
{
    assert(0);    // incomplete function
}

void mglLoadTransposeMatrixf(GLMContext ctx, const GLfloat* m)
{
    assert(0);    // incomplete function
}

void mglMultTransposeMatrixd(GLMContext ctx, GLdouble* m)
{
    assert(0);    // incomplete function
}

void mglMultTransposeMatrixf(GLMContext ctx, const GLfloat* m)
{
    assert(0);    // incomplete function
}

void mglCompressedTexImage3D(GLMContext ctx, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize,const GLvoid*data)
{
    assert(0);    // incomplete function
}

void mglCompressedTexImage2D(GLMContext ctx, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize,const GLvoid*data)
{
    assert(0);    // incomplete function
}

void mglCompressedTexImage1D(GLMContext ctx, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize,const GLvoid*data)
{
    assert(0);    // incomplete function
}

void mglCompressedTexSubImage3D(GLMContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize,const GLvoid*data)
{
    assert(0);    // incomplete function
}

void mglCompressedTexSubImage2D(GLMContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize,const GLvoid*data)
{
    assert(0);    // incomplete function
}

void mglCompressedTexSubImage1D(GLMContext ctx, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize,const GLvoid*data)
{
    assert(0);    // incomplete function
}

void mglGetCompressedTexImage(GLMContext ctx, GLenum target, GLint level,const GLvoid*img)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3b(GLMContext ctx, GLbyte red, GLbyte green, GLbyte blue)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3bv(GLMContext ctx, GLbyte* v)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3d(GLMContext ctx, GLdouble red, GLdouble green, GLdouble blue)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3f(GLMContext ctx, GLfloat red, GLfloat green, GLfloat blue)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3i(GLMContext ctx, GLint red, GLint green, GLint blue)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3s(GLMContext ctx, GLshort red, GLshort green, GLshort blue)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3ub(GLMContext ctx, GLubyte red, GLubyte green, GLubyte blue)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3ubv(GLMContext ctx, GLubyte* v)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3ui(GLMContext ctx, GLuint red, GLuint green, GLuint blue)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3uiv(GLMContext ctx, GLuint* v)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3us(GLMContext ctx, GLushort red, GLushort green, GLushort blue)
{
    assert(0);    // incomplete function
}

void mglSecondaryColor3usv(GLMContext ctx, GLushort* v)
{
    assert(0);    // incomplete function
}

void mglSecondaryColorPointer(GLMContext ctx, GLint size, GLenum type, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglVertexArrayRangeEXT(GLMContext ctx, GLsizei count,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglFlushVertexArrayRangeEXT(GLMContext ctx, GLsizei count,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglDrawRangeElements(GLMContext ctx, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type,const GLvoid*indices)
{
    assert(0);    // incomplete function
}

void mglColorTable(GLMContext ctx, GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type,const GLvoid*table)
{
    assert(0);    // incomplete function
}

void mglColorTableParameterfv(GLMContext ctx, GLenum target, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglColorTableParameteriv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglCopyColorTable(GLMContext ctx, GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
    assert(0);    // incomplete function
}

void mglGetColorTable(GLMContext ctx, GLenum target, GLenum format, GLenum type,const GLvoid*table)
{
    assert(0);    // incomplete function
}

void mglGetColorTableParameterfv(GLMContext ctx, GLenum target, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetColorTableParameteriv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglColorSubTable(GLMContext ctx, GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type,const GLvoid*data)
{
    assert(0);    // incomplete function
}

void mglCopyColorSubTable(GLMContext ctx, GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
    assert(0);    // incomplete function
}

void mglConvolutionFilter1D(GLMContext ctx, GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type,const GLvoid*image)
{
    assert(0);    // incomplete function
}

void mglConvolutionFilter2D(GLMContext ctx, GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type,const GLvoid*image)
{
    assert(0);    // incomplete function
}

void mglConvolutionParameterf(GLMContext ctx, GLenum target, GLenum pname, GLfloat params)
{
    assert(0);    // incomplete function
}

void mglConvolutionParameterfv(GLMContext ctx, GLenum target, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglConvolutionParameteri(GLMContext ctx, GLenum target, GLenum pname, GLint params)
{
    assert(0);    // incomplete function
}

void mglConvolutionParameteriv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglCopyConvolutionFilter1D(GLMContext ctx, GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
    assert(0);    // incomplete function
}

void mglCopyConvolutionFilter2D(GLMContext ctx, GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
    assert(0);    // incomplete function
}

void mglGetConvolutionFilter(GLMContext ctx, GLenum target, GLenum format, GLenum type,const GLvoid*image)
{
    assert(0);    // incomplete function
}

void mglGetConvolutionParameterfv(GLMContext ctx, GLenum target, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetConvolutionParameteriv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetSeparableFilter(GLMContext ctx, GLenum target, GLenum format, GLenum type,const GLvoid*row,const GLvoid*column,const GLvoid*span)
{
    assert(0);    // incomplete function
}

void mglSeparableFilter2D(GLMContext ctx, GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type,const GLvoid*row,const GLvoid*column)
{
    assert(0);    // incomplete function
}

void mglGetHistogram(GLMContext ctx, GLenum target, GLboolean reset, GLenum format, GLenum type,const GLvoid*values)
{
    assert(0);    // incomplete function
}

void mglGetHistogramParameterfv(GLMContext ctx, GLenum target, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetHistogramParameteriv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetMinmax(GLMContext ctx, GLenum target, GLboolean reset, GLenum format, GLenum type,const GLvoid*values)
{
    assert(0);    // incomplete function
}

void mglGetMinmaxParameterfv(GLMContext ctx, GLenum target, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetMinmaxParameteriv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglHistogram(GLMContext ctx, GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
    assert(0);    // incomplete function
}

void mglMinmax(GLMContext ctx, GLenum target, GLenum internalformat, GLboolean sink)
{
    assert(0);    // incomplete function
}

void mglResetHistogram(GLMContext ctx, GLenum target)
{
    assert(0);    // incomplete function
}

void mglResetMinmax(GLMContext ctx, GLenum target)
{
    assert(0);    // incomplete function
}

void mglTexImage3D(GLMContext ctx, GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type,const GLvoid*pixels)
{
    assert(0);    // incomplete function
}

void mglTexSubImage3D(GLMContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type,const GLvoid*pixels)
{
    assert(0);    // incomplete function
}

void mglCopyTexSubImage3D(GLMContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    assert(0);    // incomplete function
}

void mglGetUniformIndices(GLMContext ctx, GLuint program, GLsizei uniformCount, GLchar** uniformNames, GLuint* uniformIndices)
{
    assert(0);    // incomplete function
}

void mglGetActiveUniformsiv(GLMContext ctx, GLuint program, GLsizei uniformCount, GLuint* uniformIndices, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetActiveUniformName(GLMContext ctx, GLuint program, GLuint uniformIndex, GLsizei bufSize, const  GLsizei* length, GLchar* uniformName)
{
    assert(0);    // incomplete function
}

GLuint mglGetUniformBlockIndex(GLMContext ctx, GLuint program, GLchar* uniformBlockName)
{
    GLuint ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglGetActiveUniformBlockiv(GLMContext ctx, GLuint program, GLuint uniformBlockIndex, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetActiveUniformBlockName(GLMContext ctx, GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, const  GLsizei* length, GLchar* uniformBlockName)
{
    assert(0);    // incomplete function
}

void mglUniformBlockBinding(GLMContext ctx, GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
    assert(0);    // incomplete function
}

void mglGetCombinerInputParameterfvNV(GLMContext ctx, GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetCombinerInputParameterivNV(GLMContext ctx, GLenum stage, GLenum portion, GLenum variable, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetCombinerOutputParameterfvNV(GLMContext ctx, GLenum stage, GLenum portion, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetCombinerOutputParameterivNV(GLMContext ctx, GLenum stage, GLenum portion, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetFinalCombinerInputParameterfvNV(GLMContext ctx, GLenum variable, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetFinalCombinerInputParameterivNV(GLMContext ctx, GLenum variable, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglCombinerStageParameterfvNV(GLMContext ctx, GLenum stage, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetCombinerStageParameterfvNV(GLMContext ctx, GLenum stage, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglTextureRangeAPPLE(GLMContext ctx, GLenum target, GLsizei length,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglGetTexParameterPointervAPPLE(GLMContext ctx, GLenum target, GLenum pname, const GLvoid* const * params)
{
    assert(0);    // incomplete function
}

void mglBlendEquationSeparateEXT(GLMContext ctx, GLenum equationRGB, GLenum equationAlpha)
{
    assert(0);    // incomplete function
}

void mglSampleCoverage(GLMContext ctx, GLclampf value, GLboolean invert)
{
    assert(0);    // incomplete function
}

void mglSamplePass(GLMContext ctx, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglPnTrianglesiATI(GLMContext ctx, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglPnTrianglesfATI(GLMContext ctx, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglGenFencesAPPLE(GLMContext ctx, GLsizei n, GLuint* fences)
{
    assert(0);    // incomplete function
}

void mglDeleteFencesAPPLE(GLMContext ctx, GLsizei n, GLuint* fences)
{
    assert(0);    // incomplete function
}

void mglSetFenceAPPLE(GLMContext ctx, GLuint fence)
{
    assert(0);    // incomplete function
}

GLboolean mglIsFenceAPPLE(GLMContext ctx, GLuint fence)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

GLboolean mglTestFenceAPPLE(GLMContext ctx, GLuint fence)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglFinishFenceAPPLE(GLMContext ctx, GLuint fence)
{
    assert(0);    // incomplete function
}

GLboolean mglTestObjectAPPLE(GLMContext ctx, GLenum object, GLuint name)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglFinishObjectAPPLE(GLMContext ctx, GLenum object, GLuint name)
{
    assert(0);    // incomplete function
}

void mglBindProgramARB(GLMContext ctx, GLenum target, GLuint program)
{
    assert(0);    // incomplete function
}

void mglDeleteProgramsARB(GLMContext ctx, GLsizei n, GLuint* programs)
{
    assert(0);    // incomplete function
}

void mglGenProgramsARB(GLMContext ctx, GLsizei n, GLuint* programs)
{
    assert(0);    // incomplete function
}

GLboolean mglIsProgramARB(GLMContext ctx, GLuint program)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglVertexAttrib1sARB(GLMContext ctx, GLuint index, GLshort x)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib1fARB(GLMContext ctx, GLuint index, GLfloat x)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib1dARB(GLMContext ctx, GLuint index, GLdouble x)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib2sARB(GLMContext ctx, GLuint index, GLshort x, GLshort y)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib2fARB(GLMContext ctx, GLuint index, GLfloat x, GLfloat y)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib2dARB(GLMContext ctx, GLuint index, GLdouble x, GLdouble y)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib3sARB(GLMContext ctx, GLuint index, GLshort x, GLshort y, GLshort z)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib3fARB(GLMContext ctx, GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib3dARB(GLMContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4sARB(GLMContext ctx, GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4fARB(GLMContext ctx, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4dARB(GLMContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4NubARB(GLMContext ctx, GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib1svARB(GLMContext ctx, GLuint index, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib1fvARB(GLMContext ctx, GLuint index, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib1dvARB(GLMContext ctx, GLuint index, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib2svARB(GLMContext ctx, GLuint index, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib2fvARB(GLMContext ctx, GLuint index, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib2dvARB(GLMContext ctx, GLuint index, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib3svARB(GLMContext ctx, GLuint index, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib3fvARB(GLMContext ctx, GLuint index, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib3dvARB(GLMContext ctx, GLuint index, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4bvARB(GLMContext ctx, GLuint index, GLbyte* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4svARB(GLMContext ctx, GLuint index, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4ivARB(GLMContext ctx, GLuint index, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4ubvARB(GLMContext ctx, GLuint index, GLubyte* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4usvARB(GLMContext ctx, GLuint index, GLushort* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4uivARB(GLMContext ctx, GLuint index, GLuint* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4fvARB(GLMContext ctx, GLuint index, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4dvARB(GLMContext ctx, GLuint index, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4NbvARB(GLMContext ctx, GLuint index, GLbyte* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4NsvARB(GLMContext ctx, GLuint index, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4NivARB(GLMContext ctx, GLuint index, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4NubvARB(GLMContext ctx, GLuint index, GLubyte* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4NusvARB(GLMContext ctx, GLuint index, GLushort* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttrib4NuivARB(GLMContext ctx, GLuint index, GLuint* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribPointerARB(GLMContext ctx, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglEnableVertexAttribArrayARB(GLMContext ctx, GLuint index)
{
    assert(0);    // incomplete function
}

void mglDisableVertexAttribArrayARB(GLMContext ctx, GLuint index)
{
    assert(0);    // incomplete function
}

void mglGetVertexAttribdvARB(GLMContext ctx, GLuint index, GLenum pname, GLdouble* params)
{
    assert(0);    // incomplete function
}

void mglGetVertexAttribfvARB(GLMContext ctx, GLuint index, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetVertexAttribivARB(GLMContext ctx, GLuint index, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetVertexAttribPointervARB(GLMContext ctx, GLuint index, GLenum pname, const GLvoid* const * pointer)
{
    assert(0);    // incomplete function
}

void mglProgramEnvParameter4dARB(GLMContext ctx, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    assert(0);    // incomplete function
}

void mglProgramEnvParameter4dvARB(GLMContext ctx, GLenum target, GLuint index, GLdouble* params)
{
    assert(0);    // incomplete function
}

void mglProgramEnvParameter4fARB(GLMContext ctx, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    assert(0);    // incomplete function
}

void mglProgramEnvParameter4fvARB(GLMContext ctx, GLenum target, GLuint index, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglProgramLocalParameter4dARB(GLMContext ctx, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    assert(0);    // incomplete function
}

void mglProgramLocalParameter4dvARB(GLMContext ctx, GLenum target, GLuint index, GLdouble* params)
{
    assert(0);    // incomplete function
}

void mglProgramLocalParameter4fARB(GLMContext ctx, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    assert(0);    // incomplete function
}

void mglProgramLocalParameter4fvARB(GLMContext ctx, GLenum target, GLuint index, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetProgramEnvParameterdvARB(GLMContext ctx, GLenum target, GLuint index, GLdouble* params)
{
    assert(0);    // incomplete function
}

void mglGetProgramEnvParameterfvARB(GLMContext ctx, GLenum target, GLuint index, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetProgramLocalParameterdvARB(GLMContext ctx, GLenum target, GLuint index, GLdouble* params)
{
    assert(0);    // incomplete function
}

void mglGetProgramLocalParameterfvARB(GLMContext ctx, GLenum target, GLuint index, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglProgramStringARB(GLMContext ctx, GLenum target, GLenum format, GLsizei len,const GLvoid*string)
{
    assert(0);    // incomplete function
}

void mglGetProgramStringARB(GLMContext ctx, GLenum target, GLenum pname,const GLvoid*string)
{
    assert(0);    // incomplete function
}

void mglGetProgramivARB(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglEnableVertexAttribARB(GLMContext ctx, GLuint index, GLenum pname)
{
    assert(0);    // incomplete function
}

void mglDisableVertexAttribARB(GLMContext ctx, GLuint index, GLenum pname)
{
    assert(0);    // incomplete function
}

GLboolean mglIsVertexAttribEnabledARB(GLMContext ctx, GLuint index, GLenum pname)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglMapVertexAttrib1dARB(GLMContext ctx, GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, GLdouble* points)
{
    assert(0);    // incomplete function
}

void mglMapVertexAttrib1fARB(GLMContext ctx, GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points)
{
    assert(0);    // incomplete function
}

void mglMapVertexAttrib2dARB(GLMContext ctx, GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble* points)
{
    assert(0);    // incomplete function
}

void mglMapVertexAttrib2fARB(GLMContext ctx, GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points)
{
    assert(0);    // incomplete function
}

void mglPointParameterf(GLMContext ctx, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglPointParameterfv(GLMContext ctx, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglPointParameteri(GLMContext ctx, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglPointParameteriv(GLMContext ctx, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglFogCoordf(GLMContext ctx, GLfloat coord)
{
    assert(0);    // incomplete function
}

void mglFogCoordfv(GLMContext ctx, const GLfloat* coord)
{
    assert(0);    // incomplete function
}

void mglFogCoordd(GLMContext ctx, GLdouble coord)
{
    assert(0);    // incomplete function
}

void mglFogCoorddv(GLMContext ctx, GLdouble* coord)
{
    assert(0);    // incomplete function
}

void mglFogCoordPointer(GLMContext ctx, GLenum type, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglVertexArrayParameteriEXT(GLMContext ctx, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglBindVertexArrayEXT(GLMContext ctx, GLuint id)
{
    assert(0);    // incomplete function
}

void mglDeleteVertexArraysEXT(GLMContext ctx, GLsizei n, GLuint* ids)
{
    assert(0);    // incomplete function
}

void mglGenVertexArraysEXT(GLMContext ctx, GLsizei n, GLuint* ids)
{
    assert(0);    // incomplete function
}

GLboolean mglIsVertexArrayEXT(GLMContext ctx, GLuint id)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglElementPointerAPPLE(GLMContext ctx, GLenum type,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglDrawElementArrayAPPLE(GLMContext ctx, GLenum mode, GLint first, GLsizei count)
{
    assert(0);    // incomplete function
}

void mglDrawRangeElementArrayAPPLE(GLMContext ctx, GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
{
    assert(0);    // incomplete function
}

void mglWeightbvARB(GLMContext ctx, GLint size, GLbyte* weights)
{
    assert(0);    // incomplete function
}

void mglWeightsvARB(GLMContext ctx, GLint size, GLshort* weights)
{
    assert(0);    // incomplete function
}

void mglWeightivARB(GLMContext ctx, GLint size, const GLint*  weights)
{
    assert(0);    // incomplete function
}

void mglWeightfvARB(GLMContext ctx, GLint size, const GLfloat* weights)
{
    assert(0);    // incomplete function
}

void mglWeightdvARB(GLMContext ctx, GLint size, GLdouble* weights)
{
    assert(0);    // incomplete function
}

void mglWeightubvARB(GLMContext ctx, GLint size, GLubyte* weights)
{
    assert(0);    // incomplete function
}

void mglWeightusvARB(GLMContext ctx, GLint size, GLushort* weights)
{
    assert(0);    // incomplete function
}

void mglWeightuivARB(GLMContext ctx, GLint size, GLuint* weights)
{
    assert(0);    // incomplete function
}

void mglWeightPointerARB(GLMContext ctx, GLint size, GLenum type, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglVertexBlendARB(GLMContext ctx, GLint count)
{
    assert(0);    // incomplete function
}

void mglMultiDrawArrays(GLMContext ctx, GLenum mode, const GLint*  first, const  GLsizei* count, GLsizei drawcount)
{
    assert(0);    // incomplete function
}

void mglMultiDrawElements(GLMContext ctx, GLenum mode, const  GLsizei* count, GLenum type, const GLvoid* const * indices, GLsizei drawcount)
{
    assert(0);    // incomplete function
}

void mglWindowPos2d(GLMContext ctx, GLdouble x, GLdouble y)
{
    assert(0);    // incomplete function
}

void mglWindowPos2dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglWindowPos2f(GLMContext ctx, GLfloat x, GLfloat y)
{
    assert(0);    // incomplete function
}

void mglWindowPos2fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglWindowPos2i(GLMContext ctx, GLint x, GLint y)
{
    assert(0);    // incomplete function
}

void mglWindowPos2iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglWindowPos2s(GLMContext ctx, GLshort x, GLshort y)
{
    assert(0);    // incomplete function
}

void mglWindowPos2sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglWindowPos3d(GLMContext ctx, GLdouble x, GLdouble y, GLdouble z)
{
    assert(0);    // incomplete function
}

void mglWindowPos3dv(GLMContext ctx, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglWindowPos3f(GLMContext ctx, GLfloat x, GLfloat y, GLfloat z)
{
    assert(0);    // incomplete function
}

void mglWindowPos3fv(GLMContext ctx, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglWindowPos3i(GLMContext ctx, GLint x, GLint y, GLint z)
{
    assert(0);    // incomplete function
}

void mglWindowPos3iv(GLMContext ctx, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglWindowPos3s(GLMContext ctx, GLshort x, GLshort y, GLshort z)
{
    assert(0);    // incomplete function
}

void mglWindowPos3sv(GLMContext ctx, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglActiveStencilFaceEXT(GLMContext ctx, GLenum face)
{
    assert(0);    // incomplete function
}

void mglStencilOpSeparateATI(GLMContext ctx, GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
    assert(0);    // incomplete function
}

void mglStencilFuncSeparateATI(GLMContext ctx, GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
{
    assert(0);    // incomplete function
}

void mglFlushRenderAPPLE(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglFinishRenderAPPLE(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglSwapAPPLE(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglDeleteObjectARB(GLMContext ctx, GLhandleARB obj)
{
    assert(0);    // incomplete function
}

GLhandleARB mglGetHandleARB(GLMContext ctx, GLenum pname)
{
    GLhandleARB ret = NULL;

    assert(0);    // incomplete function
    return ret;
}

void mglDetachObjectARB(GLMContext ctx, GLhandleARB containerObj, GLhandleARB attachedObj)
{
    assert(0);    // incomplete function
}

GLhandleARB mglCreateShaderObjectARB(GLMContext ctx, GLenum shaderType)
{
    GLhandleARB ret = NULL;

    assert(0);    // incomplete function
    return ret;
}

void mglShaderSourceARB(GLMContext ctx, GLhandleARB shaderObj, GLsizei count, const GLcharARB* const* string, const GLint*  length)
{
    assert(0);    // incomplete function
}

void mglCompileShaderARB(GLMContext ctx, GLhandleARB shaderObj)
{
    assert(0);    // incomplete function
}

GLhandleARB mglCreateProgramObjectARB(GLMContext ctx)
{
    GLhandleARB ret = NULL;

    assert(0);    // incomplete function
    return ret;
}

void mglAttachObjectARB(GLMContext ctx, GLhandleARB containerObj, GLhandleARB obj)
{
    assert(0);    // incomplete function
}

void mglLinkProgramARB(GLMContext ctx, GLhandleARB programObj)
{
    assert(0);    // incomplete function
}

void mglUseProgramObjectARB(GLMContext ctx, GLhandleARB programObj)
{
    assert(0);    // incomplete function
}

void mglValidateProgramARB(GLMContext ctx, GLhandleARB programObj)
{
    assert(0);    // incomplete function
}

void mglUniform1fARB(GLMContext ctx, GLint location, GLfloat v0)
{
    assert(0);    // incomplete function
}

void mglUniform2fARB(GLMContext ctx, GLint location, GLfloat v0, GLfloat v1)
{
    assert(0);    // incomplete function
}

void mglUniform3fARB(GLMContext ctx, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
    assert(0);    // incomplete function
}

void mglUniform4fARB(GLMContext ctx, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
    assert(0);    // incomplete function
}

void mglUniform1iARB(GLMContext ctx, GLint location, GLint v0)
{
    assert(0);    // incomplete function
}

void mglUniform2iARB(GLMContext ctx, GLint location, GLint v0, GLint v1)
{
    assert(0);    // incomplete function
}

void mglUniform3iARB(GLMContext ctx, GLint location, GLint v0, GLint v1, GLint v2)
{
    assert(0);    // incomplete function
}

void mglUniform4iARB(GLMContext ctx, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
    assert(0);    // incomplete function
}

void mglUniform1fvARB(GLMContext ctx, GLint location, GLsizei count, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniform2fvARB(GLMContext ctx, GLint location, GLsizei count, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniform3fvARB(GLMContext ctx, GLint location, GLsizei count, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniform4fvARB(GLMContext ctx, GLint location, GLsizei count, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniform1ivARB(GLMContext ctx, GLint location, GLsizei count, const GLint*  value)
{
    assert(0);    // incomplete function
}

void mglUniform2ivARB(GLMContext ctx, GLint location, GLsizei count, const GLint*  value)
{
    assert(0);    // incomplete function
}

void mglUniform3ivARB(GLMContext ctx, GLint location, GLsizei count, const GLint*  value)
{
    assert(0);    // incomplete function
}

void mglUniform4ivARB(GLMContext ctx, GLint location, GLsizei count, const GLint*  value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix2fvARB(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix3fvARB(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix4fvARB(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglGetObjectParameterfvARB(GLMContext ctx, GLhandleARB obj, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetObjectParameterivARB(GLMContext ctx, GLhandleARB obj, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetInfoLogARB(GLMContext ctx, GLhandleARB obj, GLsizei maxLength, const  GLsizei* length, GLcharARB* infoLog)
{
    assert(0);    // incomplete function
}

void mglGetAttachedObjectsARB(GLMContext ctx, GLhandleARB containerObj, GLsizei maxCount, const  GLsizei* count, GLhandleARB* obj)
{
    assert(0);    // incomplete function
}

GLint mglGetUniformLocationARB(GLMContext ctx, GLhandleARB programObj, GLcharARB* name)
{
    GLint ret = -1;

    assert(0);    // incomplete function
    return ret;
}

void mglGetActiveUniformARB(GLMContext ctx, GLhandleARB programObj, GLuint index, GLsizei maxLength, const  GLsizei* length, const GLint*  size,const GLenum*type, GLcharARB* name)
{
    assert(0);    // incomplete function
}

void mglGetUniformfvARB(GLMContext ctx, GLhandleARB programObj, GLint location, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetUniformivARB(GLMContext ctx, GLhandleARB programObj, GLint location, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetShaderSourceARB(GLMContext ctx, GLhandleARB obj, GLsizei maxLength, const  GLsizei* length, GLcharARB* source)
{
    assert(0);    // incomplete function
}

void mglBindAttribLocationARB(GLMContext ctx, GLhandleARB programObj, GLuint index, GLcharARB* name)
{
    assert(0);    // incomplete function
}

void mglGetActiveAttribARB(GLMContext ctx, GLhandleARB programObj, GLuint index, GLsizei maxLength, const  GLsizei* length, const GLint*  size,const GLenum*type, GLcharARB* name)
{
    assert(0);    // incomplete function
}

GLint mglGetAttribLocationARB(GLMContext ctx, GLhandleARB programObj, GLcharARB* name)
{
    GLint ret = -1;

    assert(0);    // incomplete function
    return ret;
}

void mglClampColorARB(GLMContext ctx, GLenum target, GLenum clamp)
{
    assert(0);    // incomplete function
}

void mglGenQueries(GLMContext ctx, GLsizei n, GLuint* ids)
{
    assert(0);    // incomplete function
}

void mglDeleteQueries(GLMContext ctx, GLsizei n, GLuint* ids)
{
    assert(0);    // incomplete function
}

GLboolean mglIsQuery(GLMContext ctx, GLuint id)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglBeginQuery(GLMContext ctx, GLenum target, GLuint id)
{
    assert(0);    // incomplete function
}

void mglEndQuery(GLMContext ctx, GLenum target)
{
    assert(0);    // incomplete function
}

void mglGetQueryiv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetQueryObjectiv(GLMContext ctx, GLuint id, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetQueryObjectuiv(GLMContext ctx, GLuint id, GLenum pname, GLuint* params)
{
    assert(0);    // incomplete function
}

void mglBindBuffer(GLMContext ctx, GLenum target, GLuint buffer)
{
    assert(0);    // incomplete function
}

void mglDeleteBuffers(GLMContext ctx, GLsizei n, GLuint* buffers)
{
    assert(0);    // incomplete function
}

void mglGenBuffers(GLMContext ctx, GLsizei n, GLuint* buffers)
{
    assert(0);    // incomplete function
}

GLboolean mglIsBuffer(GLMContext ctx, GLuint buffer)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglBufferData(GLMContext ctx, GLenum target, GLsizeiptrARB size,const GLvoid*data, GLenum usage)
{
    assert(0);    // incomplete function
}

void mglBufferSubData(GLMContext ctx, GLenum target, GLintptrARB offset, GLsizeiptrARB size,const GLvoid*data)
{
    assert(0);    // incomplete function
}

void mglGetBufferSubData(GLMContext ctx, GLenum target, GLintptrARB offset, GLsizeiptrARB size,const GLvoid*data)
{
    assert(0);    // incomplete function
}

GLvoid* mglMapBuffer(GLMContext ctx, GLenum target, GLenum access)
{
    GLvoid* ret = NULL;

    assert(0);    // incomplete function
    return ret;
}

GLboolean mglUnmapBuffer(GLMContext ctx, GLenum target)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglGetBufferParameteriv(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetBufferPointerv(GLMContext ctx, GLenum target, GLenum pname, const GLvoid* const * params)
{
    assert(0);    // incomplete function
}

void mglDepthBoundsEXT(GLMContext ctx, GLclampd zmin, GLclampd zmax)
{
    assert(0);    // incomplete function
}

void mglDrawBuffersARB(GLMContext ctx, GLsizei n,const GLenum*bufs)
{
    assert(0);    // incomplete function
}

GLboolean mglIsShader(GLMContext ctx, GLuint shader)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

GLboolean mglIsProgram(GLMContext ctx, GLuint program)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglGetShaderiv(GLMContext ctx, GLuint shader, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetProgramiv(GLMContext ctx, GLuint program, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetShaderInfoLog(GLMContext ctx, GLuint shader, GLsizei bufSize, const  GLsizei* length, GLchar* infoLog)
{
    assert(0);    // incomplete function
}

void mglGetProgramInfoLog(GLMContext ctx, GLuint program, GLsizei bufSize, const  GLsizei* length, GLchar* infoLog)
{
    assert(0);    // incomplete function
}

void mglStencilFuncSeparate(GLMContext ctx, GLenum face, GLenum func, GLint ref, GLuint mask)
{
    assert(0);    // incomplete function
}

void mglStencilMaskSeparate(GLMContext ctx, GLenum face, GLuint mask)
{
    assert(0);    // incomplete function
}

void mglMultiDrawElementArrayAPPLE(GLMContext ctx, GLenum mode, const GLint*  first, const  GLsizei* count, GLsizei primcount)
{
    assert(0);    // incomplete function
}

void mglMultiDrawRangeElementArrayAPPLE(GLMContext ctx, GLenum mode, GLuint start, GLuint end, const GLint*  first, const  GLsizei* count, GLsizei primcount)
{
    assert(0);    // incomplete function
}

GLboolean mglIsRenderbufferEXT(GLMContext ctx, GLuint renderbuffer)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglBindRenderbufferEXT(GLMContext ctx, GLenum target, GLuint renderbuffer)
{
    assert(0);    // incomplete function
}

void mglDeleteRenderbuffersEXT(GLMContext ctx, GLsizei n, GLuint* renderbuffers)
{
    assert(0);    // incomplete function
}

void mglGenRenderbuffersEXT(GLMContext ctx, GLsizei n, GLuint* renderbuffers)
{
    assert(0);    // incomplete function
}

void mglRenderbufferStorageEXT(GLMContext ctx, GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
    assert(0);    // incomplete function
}

void mglGetRenderbufferParameterivEXT(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

GLboolean mglIsFramebufferEXT(GLMContext ctx, GLuint framebuffer)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglBindFramebufferEXT(GLMContext ctx, GLenum target, GLuint framebuffer)
{
    assert(0);    // incomplete function
}

void mglDeleteFramebuffersEXT(GLMContext ctx, GLsizei n, GLuint* framebuffers)
{
    assert(0);    // incomplete function
}

void mglGenFramebuffersEXT(GLMContext ctx, GLsizei n, GLuint* framebuffers)
{
    assert(0);    // incomplete function
}

GLenum mglCheckFramebufferStatusEXT(GLMContext ctx, GLenum target)
{
    GLenum ret = (GLenum)0;

    assert(0);    // incomplete function
    return ret;
}

void mglFramebufferTexture1DEXT(GLMContext ctx, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
    assert(0);    // incomplete function
}

void mglFramebufferTexture2DEXT(GLMContext ctx, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
    assert(0);    // incomplete function
}

void mglFramebufferTexture3DEXT(GLMContext ctx, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
    assert(0);    // incomplete function
}

void mglFramebufferRenderbufferEXT(GLMContext ctx, GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
    assert(0);    // incomplete function
}

void mglGetFramebufferAttachmentParameterivEXT(GLMContext ctx, GLenum target, GLenum attachment, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGenerateMipmapEXT(GLMContext ctx, GLenum target)
{
    assert(0);    // incomplete function
}

void mglBufferParameteriAPPLE(GLMContext ctx, GLenum target, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglFlushMappedBufferRangeAPPLE(GLMContext ctx, GLenum target, GLintptr offset, GLsizeiptr size)
{
    assert(0);    // incomplete function
}

void mglProgramEnvParameters4fvEXT(GLMContext ctx, GLenum target, GLuint index, GLsizei count, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglProgramLocalParameters4fvEXT(GLMContext ctx, GLenum target, GLuint index, GLsizei count, GLfloat* params)
{
    assert(0);    // incomplete function
}

GLenum mglObjectPurgeableAPPLE(GLMContext ctx, GLenum objectType, GLuint name, GLenum option)
{
    GLenum ret = (GLenum)0;

    assert(0);    // incomplete function
    return ret;
}

GLenum mglObjectUnpurgeableAPPLE(GLMContext ctx, GLenum objectType, GLuint name, GLenum option)
{
    GLenum ret = (GLenum)0;

    assert(0);    // incomplete function
    return ret;
}

void mglGetObjectParameterivAPPLE(GLMContext ctx, GLenum objectType, GLuint name, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglProgramParameteriEXT(GLMContext ctx, GLuint program_name, GLenum pname, GLint value)
{
    assert(0);    // incomplete function
}

void mglFramebufferTextureEXT(GLMContext ctx, GLenum target, GLenum attachment, GLuint texture, GLint level)
{
    assert(0);    // incomplete function
}

void mglFramebufferTextureLayerEXT(GLMContext ctx, GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
    assert(0);    // incomplete function
}

void mglFramebufferTextureFaceEXT(GLMContext ctx, GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
    assert(0);    // incomplete function
}

void mglBindBufferRangeEXT(GLMContext ctx, GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
    assert(0);    // incomplete function
}

void mglBindBufferOffsetEXT(GLMContext ctx, GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
    assert(0);    // incomplete function
}

void mglBindBufferBaseEXT(GLMContext ctx, GLenum target, GLuint index, GLuint buffer)
{
    assert(0);    // incomplete function
}

void mglBeginTransformFeedbackEXT(GLMContext ctx, GLenum primitiveMode)
{
    assert(0);    // incomplete function
}

void mglEndTransformFeedbackEXT(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglTransformFeedbackVaryingsEXT(GLMContext ctx, GLuint program, GLsizei count, GLchar** varyings, GLenum bufferMode)
{
    assert(0);    // incomplete function
}

void mglGetTransformFeedbackVaryingEXT(GLMContext ctx, GLuint program, GLuint index, GLsizei bufSize, const  GLsizei* length, const  GLsizei* size,const GLenum*type, GLchar* name)
{
    assert(0);    // incomplete function
}

void mglGetIntegerIndexedvEXT(GLMContext ctx, GLenum param, GLuint index, const GLint*  values)
{
    assert(0);    // incomplete function
}

void mglGetBooleanIndexedvEXT(GLMContext ctx, GLenum param, GLuint index, GLboolean* values)
{
    assert(0);    // incomplete function
}

void mglUniformBufferEXT(GLMContext ctx, GLuint program, GLint location, GLuint buffer)
{
    assert(0);    // incomplete function
}

GLint mglGetUniformBufferSizeEXT(GLMContext ctx, GLuint program, GLint location)
{
    GLint ret = -1;

    assert(0);    // incomplete function
    return ret;
}

GLintptr mglGetUniformBufferOffsetEXT(GLMContext ctx, GLuint program, GLint location)
{
    GLintptr ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglClearColorIiEXT(GLMContext ctx, GLint r, GLint g, GLint b, GLint a)
{
    assert(0);    // incomplete function
}

void mglClearColorIuiEXT(GLMContext ctx, GLuint r, GLuint g, GLuint b, GLuint a)
{
    assert(0);    // incomplete function
}

void mglTexParameterIivEXT(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglTexParameterIuivEXT(GLMContext ctx, GLenum target, GLenum pname, GLuint* params)
{
    assert(0);    // incomplete function
}

void mglGetTexParameterIivEXT(GLMContext ctx, GLenum target, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetTexParameterIuivEXT(GLMContext ctx, GLenum target, GLenum pname, GLuint* params)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI1iEXT(GLMContext ctx, GLuint index, GLint x)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI2iEXT(GLMContext ctx, GLuint index, GLint x, GLint y)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI3iEXT(GLMContext ctx, GLuint index, GLint x, GLint y, GLint z)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI4iEXT(GLMContext ctx, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI1uiEXT(GLMContext ctx, GLuint index, GLuint x)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI2uiEXT(GLMContext ctx, GLuint index, GLuint x, GLuint y)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI3uiEXT(GLMContext ctx, GLuint index, GLuint x, GLuint y, GLuint z)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI4uiEXT(GLMContext ctx, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI1ivEXT(GLMContext ctx, GLuint index, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI2ivEXT(GLMContext ctx, GLuint index, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI3ivEXT(GLMContext ctx, GLuint index, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI4ivEXT(GLMContext ctx, GLuint index, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI1uivEXT(GLMContext ctx, GLuint index, GLuint* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI2uivEXT(GLMContext ctx, GLuint index, GLuint* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI3uivEXT(GLMContext ctx, GLuint index, GLuint* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI4uivEXT(GLMContext ctx, GLuint index, GLuint* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI4bvEXT(GLMContext ctx, GLuint index, GLbyte* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI4svEXT(GLMContext ctx, GLuint index, GLshort* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI4ubvEXT(GLMContext ctx, GLuint index, GLubyte* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribI4usvEXT(GLMContext ctx, GLuint index, GLushort* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribIPointerEXT(GLMContext ctx, GLuint index, GLint size, GLenum type, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglGetVertexAttribIivEXT(GLMContext ctx, GLuint index, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetVertexAttribIuivEXT(GLMContext ctx, GLuint index, GLenum pname, GLuint* params)
{
    assert(0);    // incomplete function
}

void mglUniform1uiEXT(GLMContext ctx, GLint location, GLuint v0)
{
    assert(0);    // incomplete function
}

void mglUniform2uiEXT(GLMContext ctx, GLint location, GLuint v0, GLuint v1)
{
    assert(0);    // incomplete function
}

void mglUniform3uiEXT(GLMContext ctx, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
    assert(0);    // incomplete function
}

void mglUniform4uiEXT(GLMContext ctx, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
    assert(0);    // incomplete function
}

void mglUniform1uivEXT(GLMContext ctx, GLint location, GLsizei count, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglUniform2uivEXT(GLMContext ctx, GLint location, GLsizei count, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglUniform3uivEXT(GLMContext ctx, GLint location, GLsizei count, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglUniform4uivEXT(GLMContext ctx, GLint location, GLsizei count, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglGetUniformuivEXT(GLMContext ctx, GLuint program, GLint location, GLuint* params)
{
    assert(0);    // incomplete function
}

void mglBindFragDataLocationEXT(GLMContext ctx, GLuint program, GLuint colorNumber, GLchar* name)
{
    assert(0);    // incomplete function
}

GLint mglGetFragDataLocationEXT(GLMContext ctx, GLuint program, GLchar* name)
{
    GLint ret = -1;

    assert(0);    // incomplete function
    return ret;
}

void mglColorMaskIndexedEXT(GLMContext ctx, GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
    assert(0);    // incomplete function
}

void mglEnableIndexedEXT(GLMContext ctx, GLenum target, GLuint index)
{
    assert(0);    // incomplete function
}

void mglDisableIndexedEXT(GLMContext ctx, GLenum target, GLuint index)
{
    assert(0);    // incomplete function
}

GLboolean mglIsEnabledIndexedEXT(GLMContext ctx, GLenum target, GLuint index)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglUniformMatrix2x3fv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix3x2fv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix2x4fv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix4x2fv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix3x4fv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix4x3fv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglBlitFramebufferEXT(GLMContext ctx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
    assert(0);    // incomplete function
}

void mglRenderbufferStorageMultisampleEXT(GLMContext ctx, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    assert(0);    // incomplete function
}

void mglBeginConditionalRenderNV(GLMContext ctx, GLuint id, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglEndConditionalRenderNV(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglGetAttachedShaders(GLMContext ctx, GLuint program, GLsizei maxCount, const  GLsizei* count, GLuint* shaders)
{
    assert(0);    // incomplete function
}

void mglProvokingVertexEXT(GLMContext ctx, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglVertexAttribDivisor(GLMContext ctx, GLuint index, GLuint divisor)
{
    assert(0);    // incomplete function
}

void mglDrawArraysInstanced(GLMContext ctx, GLenum mode, GLint first, GLsizei count, GLsizei instancecount)
{
    assert(0);    // incomplete function
}

void mglDrawElementsInstanced(GLMContext ctx, GLenum mode, GLsizei count, GLenum type,const GLvoid*indices, GLsizei instancecount)
{
    assert(0);    // incomplete function
}

void mglDrawElementsBaseVertex(GLMContext ctx, GLenum mode, GLsizei count, GLenum type,const GLvoid*indices, GLint base_vertex)
{
    assert(0);    // incomplete function
}

void mglDrawRangeElementsBaseVertex(GLMContext ctx, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type,const GLvoid*indices, GLint base_vertex)
{
    assert(0);    // incomplete function
}

void mglDrawElementsInstancedBaseVertex(GLMContext ctx, GLenum mode, GLsizei count, GLenum type,const GLvoid*indices, GLsizei instancecount, GLint base_vertex)
{
    assert(0);    // incomplete function
}

void mglMultiDrawElementsBaseVertex(GLMContext ctx, GLenum mode, const  GLsizei* count, GLenum type, const GLvoid* const * indices, GLsizei drawcount, const GLint*  base_vertex)
{
    assert(0);    // incomplete function
}

void mglBindVertexArrayARB(GLMContext ctx, GLuint array)
{
    assert(0);    // incomplete function
}

void mglDeleteVertexArraysARB(GLMContext ctx, GLsizei n, GLuint* arrays)
{
    assert(0);    // incomplete function
}

void mglGenVertexArraysARB(GLMContext ctx, GLsizei n, GLuint* arrays)
{
    assert(0);    // incomplete function
}

GLboolean mglIsVertexArrayARB(GLMContext ctx, GLuint array)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglPointSizePointer(GLMContext ctx, GLenum type, GLsizei stride,const GLvoid*pointer)
{
    assert(0);    // incomplete function
}

void mglVertexPointSizefAPPLE(GLMContext ctx, GLfloat size)
{
    assert(0);    // incomplete function
}

void mglClearBufferiv(GLMContext ctx, GLenum buffer, GLint drawbuffer, const GLint*  value)
{
    assert(0);    // incomplete function
}

void mglClearBufferuiv(GLMContext ctx, GLenum buffer, GLint drawbuffer, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglClearBufferfv(GLMContext ctx, GLenum buffer, GLint drawbuffer, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglClearBufferfi(GLMContext ctx, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
    assert(0);    // incomplete function
}

GLubyte* mglGetStringi(GLMContext ctx, GLenum name, GLuint index)
{
    GLubyte *ret = NULL;

    assert(0);    // incomplete function
    return ret;
}

GLsync mglFenceSync(GLMContext ctx, GLenum condition, GLbitfield flags)
{
    GLsync ret = NULL;

    assert(0);    // incomplete function
    return ret;
}

GLboolean mglIsSync(GLMContext ctx, GLsync sync)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglDeleteSync(GLMContext ctx, GLsync sync)
{
    assert(0);    // incomplete function
}

GLenum mglClientWaitSync(GLMContext ctx, GLsync sync, GLbitfield flags, GLuint64 timeout)
{
    GLenum ret = (GLenum)0;

    assert(0);    // incomplete function
    return ret;
}

void mglWaitSync(GLMContext ctx, GLsync sync, GLbitfield flags, GLuint64 timeout)
{
    assert(0);    // incomplete function
}

void mglGetInteger64vSync(GLMContext ctx, GLenum pname, GLint64* params)
{
    assert(0);    // incomplete function
}

void mglGetSynciv(GLMContext ctx, GLsync sync, GLenum pname, GLsizei bufSize, const  GLsizei* length, const GLint*  values)
{
    assert(0);    // incomplete function
}

void mglTexImage2DMultisample(GLMContext ctx, GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
    assert(0);    // incomplete function
}

void mglTexImage3DMultisample(GLMContext ctx, GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
    assert(0);    // incomplete function
}

void mglGetMultisamplefv(GLMContext ctx, GLenum pname, GLuint index, const GLfloat* val)
{
    assert(0);    // incomplete function
}

void mglSampleMaski(GLMContext ctx, GLuint index, GLbitfield mask)
{
    assert(0);    // incomplete function
}

void mglTexBuffer(GLMContext ctx, GLenum target, GLenum internalformat, GLuint buffer)
{
    assert(0);    // incomplete function
}

void mglCopyBufferSubData(GLMContext ctx, GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
    assert(0);    // incomplete function
}

void mglPrimitiveRestartIndex(GLMContext ctx, GLuint index)
{
    assert(0);    // incomplete function
}

void mglGetQueryObjecti64v(GLMContext ctx, GLuint id, GLenum pname, GLint64EXT* params)
{
    assert(0);    // incomplete function
}

void mglGetQueryObjectui64v(GLMContext ctx, GLuint id, GLenum pname, GLuint64EXT* params)
{
    assert(0);    // incomplete function
}

GLvoid* mglMapBufferRange(GLMContext ctx, GLenum target, GLintptr offset, GLsizeiptr length, GLenum access)
{
    GLvoid* ret = NULL;

    assert(0);    // incomplete function
    return ret;
}

void mglFlushMappedBufferRange(GLMContext ctx, GLenum target, GLintptr offset, GLsizeiptr length)
{
    assert(0);    // incomplete function
}

void mglQueryCounter(GLMContext ctx, GLuint id, GLenum target)
{
    assert(0);    // incomplete function
}

void mglGetInteger64iV(GLMContext ctx, GLenum target, GLuint index, GLint64* data)
{
    assert(0);    // incomplete function
}

void mglGetBufferParameteri64v(GLMContext ctx, GLenum target, GLenum pname, GLint64* params)
{
    assert(0);    // incomplete function
}

void mglGenSamplers(GLMContext ctx, GLsizei count, GLuint* samplers)
{
    assert(0);    // incomplete function
}

void mglDeleteSamplers(GLMContext ctx, GLsizei count, GLuint* samplers)
{
    assert(0);    // incomplete function
}

GLboolean mglIsSampler(GLMContext ctx, GLuint sampler)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglBindSampler(GLMContext ctx, GLuint unit, GLuint sampler)
{
    assert(0);    // incomplete function
}

void mglSamplerParameteri(GLMContext ctx, GLuint sampler, GLenum pname, GLint param)
{
    assert(0);    // incomplete function
}

void mglSamplerParameteriv(GLMContext ctx, GLuint sampler, GLenum pname, const GLint*  param)
{
    assert(0);    // incomplete function
}

void mglSamplerParameterf(GLMContext ctx, GLuint sampler, GLenum pname, GLfloat param)
{
    assert(0);    // incomplete function
}

void mglSamplerParameterfv(GLMContext ctx, GLuint sampler, GLenum pname, const GLfloat* param)
{
    assert(0);    // incomplete function
}

void mglSamplerParameterIiv(GLMContext ctx, GLuint sampler, GLenum pname, const GLint*  param)
{
    assert(0);    // incomplete function
}

void mglSamplerParameterIuiv(GLMContext ctx, GLuint sampler, GLenum pname, GLuint* param)
{
    assert(0);    // incomplete function
}

void mglGetSamplerParameteriv(GLMContext ctx, GLuint sampler, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetSamplerParameterfv(GLMContext ctx, GLuint sampler, GLenum pname, GLfloat* params)
{
    assert(0);    // incomplete function
}

void mglGetSamplerParameterIiv(GLMContext ctx, GLuint sampler, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglGetSamplerParameterIuiv(GLMContext ctx, GLuint sampler, GLenum pname, GLuint* params)
{
    assert(0);    // incomplete function
}

void mglLabelObjectEXT(GLMContext ctx, GLenum type, GLuint object, GLsizei length, GLchar* label)
{
    assert(0);    // incomplete function
}

void mglGetObjectLabelEXT(GLMContext ctx, GLenum type, GLuint object, GLsizei bufSize, const  GLsizei* length, GLchar* label)
{
    assert(0);    // incomplete function
}

void mglInsertEventMarkerEXT(GLMContext ctx, GLsizei length, GLchar* marker)
{
    assert(0);    // incomplete function
}

void mglPushGroupMarkerEXT(GLMContext ctx, GLsizei length, GLchar* marker)
{
    assert(0);    // incomplete function
}

void mglPopGroupMarkerEXT(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglUseProgramStages(GLMContext ctx, GLuint pipeline, GLbitfield stages, GLuint program)
{
    assert(0);    // incomplete function
}

void mglActiveShaderProgram(GLMContext ctx, GLuint pipeline, GLuint program)
{
    assert(0);    // incomplete function
}

GLuint mglCreateShaderProgramv(GLMContext ctx, GLenum type, GLsizei count, GLchar** strings)
{
    GLuint ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglBindProgramPipeline(GLMContext ctx, GLuint pipeline)
{
    assert(0);    // incomplete function
}

void mglDeleteProgramPipelines(GLMContext ctx, GLsizei n, GLuint* pipelines)
{
    assert(0);    // incomplete function
}

void mglGenProgramPipelines(GLMContext ctx, GLsizei n, GLuint* pipelines)
{
    assert(0);    // incomplete function
}

GLboolean mglIsProgramPipeline(GLMContext ctx, GLuint pipeline)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglGetProgramPipelineiv(GLMContext ctx, GLuint pipeline, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglValidateProgramPipeline(GLMContext ctx, GLuint pipeline)
{
    assert(0);    // incomplete function
}

void mglGetProgramPipelineInfoLog(GLMContext ctx, GLuint pipeline, GLsizei bufSize, const  GLsizei* length, GLchar* infoLog)
{
    assert(0);    // incomplete function
}

void mglProgramUniform1i(GLMContext ctx, GLuint program, GLint location, GLint x)
{
    assert(0);    // incomplete function
}

void mglProgramUniform2i(GLMContext ctx, GLuint program, GLint location, GLint x, GLint y)
{
    assert(0);    // incomplete function
}

void mglProgramUniform3i(GLMContext ctx, GLuint program, GLint location, GLint x, GLint y, GLint z)
{
    assert(0);    // incomplete function
}

void mglProgramUniform4i(GLMContext ctx, GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w)
{
    assert(0);    // incomplete function
}

void mglProgramUniform1f(GLMContext ctx, GLuint program, GLint location, GLfloat x)
{
    assert(0);    // incomplete function
}

void mglProgramUniform2f(GLMContext ctx, GLuint program, GLint location, GLfloat x, GLfloat y)
{
    assert(0);    // incomplete function
}

void mglProgramUniform3f(GLMContext ctx, GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z)
{
    assert(0);    // incomplete function
}

void mglProgramUniform4f(GLMContext ctx, GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    assert(0);    // incomplete function
}

void mglProgramUniform1iv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLint*  value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform2iv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLint*  value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform3iv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLint*  value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform4iv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLint*  value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform1fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform2fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform3fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform4fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix2fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix3fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix4fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform1ui(GLMContext ctx, GLuint program, GLint location, GLuint x)
{
    assert(0);    // incomplete function
}

void mglProgramUniform2ui(GLMContext ctx, GLuint program, GLint location, GLuint x, GLuint y)
{
    assert(0);    // incomplete function
}

void mglProgramUniform3ui(GLMContext ctx, GLuint program, GLint location, GLuint x, GLuint y, GLuint z)
{
    assert(0);    // incomplete function
}

void mglProgramUniform4ui(GLMContext ctx, GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
    assert(0);    // incomplete function
}

void mglProgramUniform1uiv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform2uiv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform3uiv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform4uiv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix2x3fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix3x2fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix2x4fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix4x2fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix3x4fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix4x3fv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
    assert(0);    // incomplete function
}

void mglBindFragDataLocationIndexed(GLMContext ctx, GLuint program, GLuint colorNumber, GLuint index, GLchar* name)
{
    assert(0);    // incomplete function
}

GLint mglGetFragDataIndex(GLMContext ctx, GLuint program, GLchar* name)
{
    GLint ret = -1;

    assert(0);    // incomplete function
    return ret;
}

void mglBlendFuncI(GLMContext ctx, GLuint buf, GLenum src, GLenum dst)
{
    assert(0);    // incomplete function
}

void mglBlendFuncSeparateI(GLMContext ctx, GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
    assert(0);    // incomplete function
}

void mglBlendEquationI(GLMContext ctx, GLuint buf, GLenum mode)
{
    assert(0);    // incomplete function
}

void mglBlendEquationSeparateI(GLMContext ctx, GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
    assert(0);    // incomplete function
}

void mglNamedStringARB(GLMContext ctx, GLenum type, GLint namelen, GLchar* name, GLint stringlen, GLchar* string)
{
    assert(0);    // incomplete function
}

void mglDeleteNamedStringARB(GLMContext ctx, GLint namelen, GLchar* name)
{
    assert(0);    // incomplete function
}

void mglCompileShaderIncludeARB(GLMContext ctx, GLuint shader, GLsizei count, GLchar** path, const GLint*  length)
{
    assert(0);    // incomplete function
}

GLboolean mglIsNamedStringARB(GLMContext ctx, GLint namelen, GLchar* name)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglGetNamedStringARB(GLMContext ctx, GLint namelen, GLchar* name, GLsizei bufSize, const GLint*  stringlen, GLchar* string)
{
    assert(0);    // incomplete function
}

void mglGetNamedStringIvARB(GLMContext ctx, GLint namelen, GLchar* name, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglReleaseShaderCompiler(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglShaderBinary(GLMContext ctx, GLint n, GLuint* shaders, GLenum binaryformat,const GLvoid*binary, GLint length)
{
    assert(0);    // incomplete function
}

void mglGetShaderPrecisionFormat(GLMContext ctx, GLenum shadertype, GLenum precisiontype, const GLint*  range, const GLint*  precision)
{
    assert(0);    // incomplete function
}

void mglDepthRangef(GLMContext ctx, GLclampf zNear, GLclampf zFar)
{
    assert(0);    // incomplete function
}

void mglClearDepthf(GLMContext ctx, GLclampf depth)
{
    assert(0);    // incomplete function
}

void mglVertexAttribP1ui(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
    assert(0);    // incomplete function
}

void mglVertexAttribP2ui(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
    assert(0);    // incomplete function
}

void mglVertexAttribP3ui(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
    assert(0);    // incomplete function
}

void mglVertexAttribP4ui(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
    assert(0);    // incomplete function
}

void mglVertexAttribP1uiv(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglVertexAttribP2uiv(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglVertexAttribP3uiv(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglVertexAttribP4uiv(GLMContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint* value)
{
    assert(0);    // incomplete function
}

void mglGetProgramBinary(GLMContext ctx, GLuint program, GLsizei bufSize, const  GLsizei* length,const GLenum*binaryFormat,const GLvoid*binary)
{
    assert(0);    // incomplete function
}

void mglProgramBinary(GLMContext ctx, GLuint program, GLenum binaryFormat,const GLvoid*binary, GLsizei length)
{
    assert(0);    // incomplete function
}

void mglMinSampleShading(GLMContext ctx, GLclampf value)
{
    assert(0);    // incomplete function
}

void mglViewportArrayv(GLMContext ctx, GLuint first, GLsizei count, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglViewportIndexedf(GLMContext ctx, GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
    assert(0);    // incomplete function
}

void mglViewportIndexedfv(GLMContext ctx, GLuint index, const GLfloat* v)
{
    assert(0);    // incomplete function
}

void mglScissorArrayv(GLMContext ctx, GLuint first, GLsizei count, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglScissorIndexed(GLMContext ctx, GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height)
{
    assert(0);    // incomplete function
}

void mglScissorIndexedv(GLMContext ctx, GLuint index, const GLint*  v)
{
    assert(0);    // incomplete function
}

void mglDepthRangeArrayv(GLMContext ctx, GLuint first, GLsizei count, GLclampd* v)
{
    assert(0);    // incomplete function
}

void mglDepthRangeIndexed(GLMContext ctx, GLuint index, GLclampd n, GLclampd f)
{
    assert(0);    // incomplete function
}

void mglGetFloatiV(GLMContext ctx, GLenum target, GLuint index, const GLfloat* data)
{
    assert(0);    // incomplete function
}

void mglGetDoubleiV(GLMContext ctx, GLenum target, GLuint index, GLdouble* data)
{
    assert(0);    // incomplete function
}

void mglDrawArraysIndirect(GLMContext ctx, GLenum mode,const GLvoid*indirect)
{
    assert(0);    // incomplete function
}

void mglDrawElementsIndirect(GLMContext ctx, GLenum mode, GLenum type,const GLvoid*indirect)
{
    assert(0);    // incomplete function
}

void mglPatchParameteri(GLMContext ctx, GLenum pname, GLint value)
{
    assert(0);    // incomplete function
}

void mglPatchParameterfv(GLMContext ctx, GLenum pname, const GLfloat* values)
{
    assert(0);    // incomplete function
}

void mglBindTransformFeedback(GLMContext ctx, GLenum target, GLuint name)
{
    assert(0);    // incomplete function
}

void mglGenTransformFeedbacks(GLMContext ctx, GLsizei n, GLuint* ids)
{
    assert(0);    // incomplete function
}

void mglDeleteTransformFeedbacks(GLMContext ctx, GLsizei n, GLuint* ids)
{
    assert(0);    // incomplete function
}

void mglPauseTransformFeedback(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglResumeTransformFeedback(GLMContext ctx)
{
    assert(0);    // incomplete function
}

GLboolean mglIsTransformFeedback(GLMContext ctx, GLuint name)
{
    GLboolean ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglDrawTransformFeedback(GLMContext ctx, GLenum mode, GLuint name)
{
    assert(0);    // incomplete function
}

void mglBeginQueryIndexed(GLMContext ctx, GLenum target, GLuint index, GLuint id)
{
    assert(0);    // incomplete function
}

void mglEndQueryIndexed(GLMContext ctx, GLenum target, GLuint index)
{
    assert(0);    // incomplete function
}

void mglGetQueryIndexediv(GLMContext ctx, GLenum target, GLuint index, GLenum pname, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglDrawTransformFeedbackStream(GLMContext ctx, GLenum mode, GLuint name, GLuint stream)
{
    assert(0);    // incomplete function
}

void mglProgramUniform1d(GLMContext ctx, GLuint program, GLint location, GLdouble x)
{
    assert(0);    // incomplete function
}

void mglProgramUniform2d(GLMContext ctx, GLuint program, GLint location, GLdouble x, GLdouble y)
{
    assert(0);    // incomplete function
}

void mglProgramUniform3d(GLMContext ctx, GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
    assert(0);    // incomplete function
}

void mglProgramUniform4d(GLMContext ctx, GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    assert(0);    // incomplete function
}

void mglProgramUniform1dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform2dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform3dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniform4dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix2dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix3dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix4dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix2x3dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix3x2dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix2x4dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix4x2dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix3x4dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglProgramUniformMatrix4x3dv(GLMContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniform1d(GLMContext ctx, GLint location, GLdouble x)
{
    assert(0);    // incomplete function
}

void mglUniform2d(GLMContext ctx, GLint location, GLdouble x, GLdouble y)
{
    assert(0);    // incomplete function
}

void mglUniform3d(GLMContext ctx, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
    assert(0);    // incomplete function
}

void mglUniform4d(GLMContext ctx, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    assert(0);    // incomplete function
}

void mglUniform1dv(GLMContext ctx, GLint location, GLsizei count, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniform2dv(GLMContext ctx, GLint location, GLsizei count, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniform3dv(GLMContext ctx, GLint location, GLsizei count, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniform4dv(GLMContext ctx, GLint location, GLsizei count, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix2dv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix3dv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix4dv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix2x3dv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix3x2dv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix2x4dv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix4x2dv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix3x4dv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglUniformMatrix4x3dv(GLMContext ctx, GLint location, GLsizei count, GLboolean transpose, GLdouble* value)
{
    assert(0);    // incomplete function
}

void mglGetUniformdv(GLMContext ctx, GLuint program_obj, GLint location, GLdouble* params)
{
    assert(0);    // incomplete function
}

void mglVertexAttribl1d(GLMContext ctx, GLuint index, GLdouble x)
{
    assert(0);    // incomplete function
}

void mglVertexAttribl2d(GLMContext ctx, GLuint index, GLdouble x, GLdouble y)
{
    assert(0);    // incomplete function
}

void mglVertexAttribl3d(GLMContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
    assert(0);    // incomplete function
}

void mglVertexAttribl4d(GLMContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    assert(0);    // incomplete function
}

void mglVertexAttribl1dv(GLMContext ctx, GLuint index, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribl2dv(GLMContext ctx, GLuint index, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribl3dv(GLMContext ctx, GLuint index, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribl4dv(GLMContext ctx, GLuint index, GLdouble* v)
{
    assert(0);    // incomplete function
}

void mglVertexAttribLpointer(GLMContext ctx, GLuint index, GLint size, GLenum type, GLsizei stride, void* pointer)
{
    assert(0);    // incomplete function
}

void mglGetVertexAttribLdv(GLMContext ctx, GLuint index, GLenum pname, GLdouble* params)
{
    assert(0);    // incomplete function
}

GLint mglGetSubroutineUniformLocation(GLMContext ctx, GLuint program, GLenum shadertype, GLchar* name)
{
    GLint ret = -1;

    assert(0);    // incomplete function
    return ret;
}

GLuint mglGetSubroutineIndex(GLMContext ctx, GLuint program, GLenum shadertype, GLchar* name)
{
    GLuint ret = 0;

    assert(0);    // incomplete function
    return ret;
}

void mglGetActiveSubroutineUniformiv(GLMContext ctx, GLuint program, GLenum shadertype, GLuint index, GLenum pname, const GLint*  values)
{
    assert(0);    // incomplete function
}

void mglGetActiveSubroutineUniformName(GLMContext ctx, GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, const  GLsizei* length, GLchar* name)
{
    assert(0);    // incomplete function
}

void mglGetActiveSubroutineName(GLMContext ctx, GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, const  GLsizei* length, GLchar* name)
{
    assert(0);    // incomplete function
}

void mglUniformSubroutinesuiv(GLMContext ctx, GLenum shadertype, GLsizei count, GLuint* indices)
{
    assert(0);    // incomplete function
}

void mglGetUniformSubroutineuiv(GLMContext ctx, GLenum shadertype, GLint location, GLuint* params)
{
    assert(0);    // incomplete function
}

void mglGetProgramStageiv(GLMContext ctx, GLuint program, GLenum shadertype, GLenum pname, const GLint*  values)
{
    assert(0);    // incomplete function
}

void mglGetInternalFormativ(GLMContext ctx, GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, const GLint*  params)
{
    assert(0);    // incomplete function
}

void mglTexStorage1D(GLMContext ctx, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
    assert(0);    // incomplete function
}

void mglTexStorage2D(GLMContext ctx, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
    assert(0);    // incomplete function
}

void mglTexStorage3D(GLMContext ctx, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
    assert(0);    // incomplete function
}

void mglLabelObjectWithResponsibleProcessAPPLE(GLMContext ctx, GLenum type, GLuint name, GLint pid)
{
    assert(0);    // incomplete function
}

void mglTextureBarrierNV(GLMContext ctx)
{
    assert(0);    // incomplete function
}

void mglMultiDrawElementsIndirectAPPLE(GLMContext ctx, GLenum mode, GLenum type,const GLvoid*indirect, GLsizei drawcount, GLsizei stride)
{
    assert(0);    // incomplete function
}

